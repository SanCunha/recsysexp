import {ArgumentType, ArgumentValue, RecipeId, RecipeUsage} from "./TypeAliases";
import {Task} from "./Task";
import {Process} from "./Process";

/**
 * Recipes are used to generate {@link Task tasks}.
 */
export class Recipe {

  private _id: RecipeId;

  /**
   * If two tasks generated by two dependant {@link Process Processes} have different pruning
   * {@link ArgumentType ArgumentTypes} values, they are considered independent.
   */
  private _pruning: Array<ArgumentType>;

  /**
   * Recipe usages are used to generate a cartesian product of {@link ArgumentType ArgumentTypes}.
   * This cartesian product will be used to generate different {@link Task Tasks} of a {@link Process}.
   * <p>
   * For example:
   *
   * If a process P has 3 arguments, lets say
   * <br><tt>process.sh {A} {B} {C}</tt><br>
   * and this process has the following recipe<br>
   * <pre>
   *   A: [A1, A2]
   *   B: [B1]
   *   C: [C1, C2]
   *   Z: [Z1, Z2, Z3] => will be ignored once P does not have Z arguments
   * </pre>
   * the following cartesian product will be generated:<br>
   *
   * <pre>
   *   [A1, B1, C1]
   *   [A1, B1, C2]
   *   [A2, B1, C1]
   *   [A2, B1, C2]
   * </pre>
   *
   * and this will be used to generate the following command lines ({@link Task Tasks}):
   *
   * <pre>
   *   process.sh A1 B1 C1
   *   process.sh A1 B1 C2
   *   process.sh A2 B1 C1
   *   process.sh A2 B1 C2
   * </pre>
   */
  private _uses: RecipeUsage;

  constructor(id: RecipeId, pruning: Array<ArgumentType>, uses: RecipeUsage) {
    this._id = id;
    this._pruning = pruning;
    this._uses = uses;
  }

  get id(): number | string {
    return this._id;
  }

  set id(value: number | string) {
    this._id = value;
  }

  get pruning(): Array<ArgumentType> {
    return this._pruning;
  }

  set pruning(value: Array<ArgumentType>) {
    this._pruning = value;
  }

  get uses(): Map<ArgumentType, Array<ArgumentValue>> {
    return this._uses;
  }

  set uses(value: Map<ArgumentType, Array<ArgumentValue>>) {
    this._uses = value;
  }
}