import {Task} from "./Task";
import {ExperimentSettings} from "./ExperimentSettings";
import {Process} from "./Process";
import {Recipe} from "./Recipe";
import {ArgumentMap, ArgumentType, ArgumentValue, RecipeId, RecipeUsage, TaskId} from "./TypeAliases";
import {Command} from "./Command";
import {cartesianProduct, getCommandArgumentTypes} from "./Utils";

/**
 * This class is responsible to generate all {@link Task tasks} used by the framework.
 */
export class TaskBuilder {

  public build(experimentSettings: ExperimentSettings): Array<Task> {
    const tasks = this.generateTasks(experimentSettings);
    return this.computeDependencies(experimentSettings, tasks);
  }

  private generateTasks(experimentSettings: ExperimentSettings) {
    const tasks: Array<Task> = [];

    for (const process of experimentSettings.processes) {
      for (const recipe of experimentSettings.recipes) {
        let argumentMappings = this.generateArgumentMappings(process, recipe, experimentSettings.recipeDefaults);

        let count = 0;

        for (const argumentMap of argumentMappings) {
          const task = new Task();
          task.processId = process.id;
          task.recipeId = recipe.id;
          task.command = new Command(process.commandTemplate, argumentMap);
          // TODO generate task id with mongose
          task.id = `${process.id}_${recipe.id}_${++count}`;
          tasks.push(task);
        }
      }
    }
    return tasks;
  }

// noinspection JSMethodCanBeStatic
  private computeDependencies(experimentSettings: ExperimentSettings, tasks: Array<Task>): Array<Task> {

    // Dependencies between Tasks occurs only in recipe scope, i.e, tasks
    // generated by different recipes should never be dependant
    const tasksGroupedByRecipe = new Map<RecipeId, Array<Task>>();

    // Caching for later queries
    for (const recipe of experimentSettings.recipes) {
      tasksGroupedByRecipe.set(recipe.id, tasks.filter(task => {
        return task.recipeId === recipe.id;
      }))
    }

    for (const recipe of experimentSettings.recipes) {
      const tasksInCurrentRecipe = tasksGroupedByRecipe.get(recipe.id);

      for (const currentTask of tasksInCurrentRecipe) {
        const currentTaskProcess = experimentSettings.processes.find(p => p.id === currentTask.processId);

        const newDependenciesOfCurrentTask = tasksInCurrentRecipe.filter(t => {
          if (currentTaskProcess.deps.includes(t.processId)) {
            for (const pruningArgumentType of recipe.pruning) {
              if (currentTask.command.arguments.get(pruningArgumentType) !== t.command.arguments.get(pruningArgumentType)) {
                return false;
              }
            }
            return true;
          }
          return false;
        });

        if (newDependenciesOfCurrentTask.length > 0) {
          const newDependencyIds: Array<TaskId>
            = newDependenciesOfCurrentTask.map((dependency: Task): TaskId => dependency.id);
          currentTask.dependencyIds = currentTask.dependencyIds.concat(newDependencyIds);
        }
      }
    }

    return tasks;
  }

  /**
   * @brief Generate a cartesian product of process arguments.
   *
   * @description Every {@link ArgumentMap} generated by this method will be used
   */
  private generateArgumentMappings(process: Process, recipe: Recipe, recipeDefaults: RecipeUsage): Array<ArgumentMap> {
    const processRequiredArgumentTypes: Array<ArgumentType> = getCommandArgumentTypes(process.commandTemplate);
    const shrunkenRecipe = this.ensureRecipeArgument(process, recipe, recipeDefaults);
    const product: Array<Array<ArgumentValue>> = cartesianProduct([...shrunkenRecipe.values()]);

    const argumentMappings: Array<ArgumentMap> = [];

    product.forEach((argumentValues) => {
      const argumentMap: ArgumentMap = new Map<ArgumentType, ArgumentValue>();

      processRequiredArgumentTypes.forEach((requiredArgument, index) => {
        argumentMap.set(requiredArgument, argumentValues[index]);
      });

      argumentMappings.push(argumentMap);
    });

    return argumentMappings;
  }

  // noinspection JSMethodCanBeStatic
  /**
   * Ensure that recipes contains required argument from process.
   *
   * @return a shrunken recipe that contains all arguments required by process.
   */
  private ensureRecipeArgument(process: Process, recipe: Recipe, recipeDefaults: RecipeUsage): RecipeUsage {
    const processRequiredArgumentTypes: Array<ArgumentType> = getCommandArgumentTypes(process.commandTemplate);
    const _recipe: RecipeUsage = new Map<ArgumentType, Array<ArgumentValue>>();

    for (let requiredArgument of processRequiredArgumentTypes) {
      if (recipe.uses.get(requiredArgument)) {
        _recipe.set(requiredArgument, recipe.uses.get(requiredArgument));
      } else {
        if (recipeDefaults.get(requiredArgument)) {
          _recipe.set(requiredArgument, recipeDefaults.get(requiredArgument));
        } else {
          throw new Error(`Required argument "${requiredArgument}" from process "${process.id}" not found`);
        }
      }
    }

    return _recipe;
  }
}